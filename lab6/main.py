"""
Приклад використання декоратора readonly.
Автор: Степанюк Каріна

=== ЩО РОБИТЬ ЦЯ ПРОГРАМА? ===
1. Створює дві функції: suma і pomnozh
2. Позначає їх декоратором @readonly
3. Викликає ці функції (все працює)
4. Намагається перевизначити функцію suma
5. Ловить помилку через try-except
"""

# Імпортуємо (завантажуємо) декоратор і функцію перевірки
# from модуль import що_імпортувати
# readonly_decorator - це файл readonly_decorator.py (без .py)
from deco import readonly, check_readonly


# === ДЕКОРАТОР @readonly ===
# @ - це синтаксис декоратора
# @readonly означає: suma = readonly(suma)
# Тобто функція suma ЗМІНЮЄТЬСЯ декоратором
@readonly
def suma(a, b):
    """Функція додавання двох чисел."""
    # return - повертає результат
    # a + b - додавання
    return a + b


# Ще одна функція з декоратором
@readonly
def pomnozh(a, b):
    """Функція множення двох чисел."""
    # a * b - множення
    return a * b


# === ТЕСТ 1: Виклик функцій ===
# print() - функція виведення тексту на екран
# "текст", значення - через кому print сам додає пробіл
print("=== Тест 1: Виклик функцій ===")

# suma(5, 3) - викликаємо функцію suma з аргументами 5 і 3
# Результат: 5 + 3 = 8
print("Сума: 5 + 3 =", suma(5, 3))

# pomnozh(4, 7) - викликаємо функцію pomnozh
# Результат: 4 * 7 = 28
print("Множення: 4 * 7 =", pomnozh(4, 7))


# === ТЕСТ 2: Перевірка атрибута __readonly__ ===
# \n - символ переносу на новий рядок (робить порожній рядок)
print("\n=== Тест 2: Перевірка readonly ===")

# hasattr(об'єкт, 'атрибут') - перевіряє наявність атрибута
# Повертає True або False
# suma - це об'єкт функції
# '__readonly__' - ім'я атрибута, який ми шукаємо
# Результат: True, бо ми додали цей атрибут в декораторі
print("Функція suma є readonly?", hasattr(suma, '__readonly__'))


# === ТЕСТ 3: Спроба перевизначити функцію ===
print("\n=== Тест 3: Спроба перевизначити ===")

# === ЩО ТАКЕ TRY-EXCEPT? ===
# try - "спробуй виконати цей код"
# except - "якщо виникне помилка, зроби це"
#
# Це як страховка:
#   try:
#       Код, який може викликати помилку
#   except ТипПомилки as змінна:
#       Що робити, якщо виникла помилка
try:
    # Викликаємо check_readonly для перевірки
    # Передаємо:
    #   'suma' - ім'я функції (рядок)
    #   lambda x, y: x - y - нова функція, якою хочемо замінити
    #
    # lambda - це анонімна (без імені) функція
    # lambda x, y: x - y  еквівалентно:
    #   def temp(x, y):
    #       return x - y
    check_readonly('suma', lambda x, y: x - y)
    
    # Якщо check_readonly НЕ викинув помилку, робимо перевизначення
    # suma = нове_значення
    # АЛЕ цей рядок НЕ ВИКОНАЄТЬСЯ, бо check_readonly викине AttributeError
    suma = lambda x, y: x - y
    
    # Цей print теж не виконається
    print("❌ Функцію перевизначено")

# except AttributeError as e - "якщо виникла помилка AttributeError"
# as e - зберігаємо об'єкт помилки в змінну e
# e містить текст помилки, який ми передали в raise AttributeError(...)
except AttributeError as e:
    # Виводимо ✅ (все добре, помилка спрацювала як треба)
    # e - це текст помилки з декоратора
    print("✅", e)

# === ІНШІ ВАРІАНТИ EXCEPT ===
# except ValueError as e:        - ловить ValueError
# except TypeError as e:         - ловить TypeError  
# except Exception as e:         - ловить ВСІ помилки
# except:                        - ловить все (не рекомендується)


# === ТЕСТ 4: Функція все ще працює ===
print("\n=== Тест 4: Функція все ще працює ===")

# Перевіряємо, що функція suma НЕ ЗМІНИЛАСЯ
# Вона все ще рахує суму, а не віднімання
# suma(10, 20) -> 10 + 20 = 30
print("Сума: 10 + 20 =", suma(10, 20))

# === ПІДСУМОК ===
# 1. Декоратор @readonly додав атрибут __readonly__ = True
# 2. Функція check_readonly перевіряє цей атрибут
# 3. Якщо атрибут є, викидається помилка AttributeError
# 4. try-except ловить цю помилку і виводить повідомлення
# 5. Функція залишається незмінною!
